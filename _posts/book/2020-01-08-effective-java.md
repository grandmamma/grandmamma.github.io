---
title: "Effective Java"
categories: 
  - 도서
tags: 
  - 도서
last_modified_at: 2020-01-08T00:00:00+09:00
toc: true
toc_sticky: true
---
# 객체의 생성과 삭제
- 객체 생성 시점, 방법
- 객체 생성을 피해야 하는 경우, 방법
- 객체 삭제 보장 방법
- 객체 삭제 전 청소 작업 관리

## <a name="rule1">**규칙1**</a> : 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해 보라
{% highlight java linenos %}
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
{% endhighlight %}
- 장점1 : 생성자와는 달리 정적 팩터리 메서드에는 이름(name)이 있다.
- 장점2 : 생성자와는 달리 호출할 때마다 새로운 객체를 생성할 필요는 없다.
  - 변경 불가능 클래스(**규칙15**)라면 이미 만들어 둔 객체를 활용할 수도 있고,
  만든 객체를 캐시(cache) 해놓고 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수도 있다.
  - 개체 수를 제어하면 싱글턴 패턴을 따르도록 할 수 있다([**규칙3**](#rule3)
  - 객체 생성이 불가능한 클래스를 만들 수도 있다(**규칙4**)
  - 변경이 불가능한 클래스의 경우(**규칙15**) 두 개의 같은 객체가 존재하지 못하도록 할 수도 있다.
    - 즉 a == b 일 때만 a.equals(b)가 참이 되도록 만들 수 있다.
    - 이렇게 구현된 클래스는 equals(Object) 대신 == 연산자를 사용하여 비교할 수 있으므로 성능이 향상된다.
    - 열거 자료형(**규칙30**)이 기법을 사용한다.
- 장점3 : 생성자와는 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
  - 이는 public으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다.
  - 이 기법은 인터페이스 기반 프레임워크 구현에 적합(**규칙18**)
    - 인터페이스는 정적 메서드를 가질 수 없으므로, 관습상 반환값 자료형이 Type이라는 이름의 인터페이스인 정적 팩터리 메서드는 
    Types라는 이름의 객체 생성 불가능 클래스(**규칙4**) 안에 둔다.
    - 클라이언트 코드는 반환된 객체의 실제 구현 세부사항이 아니라 인터페이스만 보고 작성하게 되는데, 일반적으로 바람직한 습관이다(**규칙52**)
  - JDK 1.5부터 도입된 java.util.EnumSet(규칙32)에는 public으로 선언된 생성자가 없으며, 정적 팩터리 메서드뿐이다.
- 장점4 : 형인자 자료형(parameterized type) 객체를 만들 때 편하다.

- 단점1 : public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다.
- 단점2 : 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다.

## <a name="rule3">**규칙3**</a> : private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라

# 열거형(enum)과 어노테이션
자바 1.5에는 새로운 참조 자료형(reference type)이 추가되었다. 열거형(enum type)이라 불리는 새로운 종류의 클래스와, 어노테이션 자료형이라 불리는 새로운 종류의 인터페이스가 그것이다.
